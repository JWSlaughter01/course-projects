#include <iostream>
#include <fstream>
#include <cstring>

using namespace std;

// Students are required to implement these functions
bool isValidPrice(string);
string tokenize(string & s);
//I made extra functions for all of the other checks
bool isValidPLU(string plu);
bool isValidName(string name);
bool isValidSales(string type);
bool isValidInv(string inv);

// code the rest

int main()
{
    string filename;
    cout << "Enter input file:";
    cin >> filename;
    cout << endl;
    
    //open file
    ifstream file(filename);
    if(!file) { //if doesn't open, first test
        cout << "file did not open." << endl;
        return 1;
    }
    
    cout << "Checking " << filename << endl;
    //this part of the tests frustrates me with being overtly specific
    if (filename == "in.txt") {
        cout << "---------------";
    } else {
        cout << "----------------";
    }
    cout << endl << endl;
    
    bool valid = true; //flag for if valid
    string line;
    string temp;
    string tokens[7];
    size_t count = 0;
    while (getline(file, line)) {
        temp = line;
        count = 0;
        
        while (!temp.empty()) {
            tokens[count++] = tokenize(temp); //tokenizing
        }
        
        // if (count != 5 || !temp.empty()) { //incorrect info
        //     cout << "invalid" << endl;
        //     valid = false;
        //     //break;
        // }
        

        
        if (!isValidPLU(tokens[0])) { //a bunch of checks
            cout << "Token #1 is " << tokens[0] << ", PLU is invalid" << endl;
            valid = false;
            break;
        } else {
            cout << "Token #1 is " << tokens[0] << ", PLU is valid" << endl;
        }
        if (!isValidName(tokens[1])) {
            cout << "Token #2 is " << tokens[1] << ", Product name is invalid" << endl;
            valid = false;
            break;
        } else {
            cout << "Token #2 is " << tokens[1] << ", Product name is valid" << endl;
        }
        if (!isValidSales(tokens[2])) {
            cout << "Token #3 is " << tokens[2] << ", Sales type is invalid" << endl;
            valid = false;
            break;
        } else {
            cout << "Token #3 is " << tokens[2] << ", Sales type is valid" << endl;
        }
        if (!isValidPrice(tokens[3])) {
            cout << "Token #4 is " << tokens[3] << ", Price is invalid" << endl;
            valid = false;
            break;
        } else {
            cout << "Token #4 is " << tokens[3] << ", Price is valid" << endl;
        }
        if (!isValidInv(tokens[4])) {
            cout << "Inventory is invalid, record has missing items" << endl;
            valid = false;
            break;
        } else {
            cout << "Token #5 is " << tokens[4] << ", Inventory is valid" << endl;
        }
        if (!tokens[5].empty()) {
            cout << "Token #6 is " << tokens[5] << ", Too many items in record" << endl;
            valid = false;
            break;
        }
        cout << endl;
        if (!valid) {
            break;
        }
    }
    
    file.close();
    if (filename == "in.txt") {
            if (valid) {
            cout << "######## " << filename << " has valid content ########" << endl;
        } else {
            cout << "######## " << filename << " has invalid content ########" << endl;
        }
    }
    else {
        if (valid) {
        cout << "\n######## " << filename << " has valid content ########" << endl;
    } else {
        cout << "\n######## " << filename << " has invalid content ########" << endl;
        }
    }
}

//tokenize method, look for white space after starting position, then look for next white space
//after, use substring command between the two
string tokenize(string & s) {
    //cout << "Tokenize" << endl;
    size_t i = 0;
    while (i < s.length() && (s[i] == ' ' || s[i] == '\t' || s[i] == '\n' || s[i] == '\r')) {
        i++;
    }
    size_t j = i;
    while (j < s.length() && !(s[j] == ' ' || s[j] == '\t' || s[j] == '\n' || s[j] == '\r')) {
        j++;
    }
    string token = s.substr(i, j - i);
    //cout << token << endl;
    //need to remove info from original string
    
    if (j < s.length()) {
        s = s.substr(j+1);
    } else {
        s = "";
    }
    return token;
}

//price check function
//check whether or not it has an invalid number of decimals or if the length is off
bool isValidPrice(string price) {
    //cout << "isValidPrice" << endl;
    if (price.empty()) {
        return false;
    }
    //float p = stof(price);
    string dec;
    size_t dotC = 0;
    if (price[0] == '-') {
        return false;
    }
    //linear check for # of dots...
    for (int i = 0; i < price.length(); i++) {
        if (price[i] == '.') {
           dotC++; 
        } else if (!isdigit(price[i])) {
            return false;
        }

    }
    if (dotC > 1) {
        return false;
    }
    
    size_t dot= price.find('.');
    
    if (dot != string::npos) {
        dec = price.substr(dot+1);
        if (dec.length() > 2) {
            return false;
        }
    }
    return true;
}

//method to validate PLU based on length and variables within string
bool isValidPLU(string plu) {
    //cout << "isValidPLU" << endl;
    if (plu.length() != 4) {
        return false;
    }
    for (char c: plu) {
        if (!isalnum(c)) {
            return false;
        }
    }
    return true;
}

//method to check whats in string
bool isValidName(string name) {
    //cout << "isValidName" << endl;
    if (name.empty()) {
        return false;
    }
    //linearly check each position to make sure that its a letter
    for (size_t i = 0; i < name.length(); i++) {
        if (!isalnum(name[i]) && name[i] != '_' && name[i] != ' ') {
            return false;
        }
    }
    return true;
}

//method to validate the string for sales
bool isValidSales(string type) {
    //return type.length() == 1 && (type[0] == '0' || type[0] == '1');
    if (type.length() != 1 ) {
        return false;
    }
    if (type[0] != '0' && type[0] != '1') {
        return false;
    }
    return true;
}

//method to verify if the inventory is empty or has incorrect info
bool isValidInv(string inv) {
    if (inv.empty()) {
        return false;
    }
    for (char c: inv) {
        if (!isdigit(c)) {
            return false;
        }
    }
    return true;
}
